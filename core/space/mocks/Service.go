// Code generated by mockery v2.3.0. DO NOT EDIT.

package mocks

import (
	context "context"

	domain "github.com/FleekHQ/space-daemon/core/space/domain"
	crypto "github.com/libp2p/go-libp2p-core/crypto"

	io "io"

	mock "github.com/stretchr/testify/mock"

	services "github.com/FleekHQ/space-daemon/core/space/services"

	textile "github.com/FleekHQ/space-daemon/core/textile"
)

// Service is an autogenerated mock type for the Service type
type Service struct {
	mock.Mock
}

// AddItemWithReader provides a mock function with given fields: ctx, reader, targetPath, bucketName
func (_m *Service) AddItemWithReader(ctx context.Context, reader io.Reader, targetPath string, bucketName string) (domain.AddItemResult, error) {
	ret := _m.Called(ctx, reader, targetPath, bucketName)

	var r0 domain.AddItemResult
	if rf, ok := ret.Get(0).(func(context.Context, io.Reader, string, string) domain.AddItemResult); ok {
		r0 = rf(ctx, reader, targetPath, bucketName)
	} else {
		r0 = ret.Get(0).(domain.AddItemResult)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, io.Reader, string, string) error); ok {
		r1 = rf(ctx, reader, targetPath, bucketName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddItems provides a mock function with given fields: ctx, sourcePaths, targetPath, bucketName
func (_m *Service) AddItems(ctx context.Context, sourcePaths []string, targetPath string, bucketName string) (<-chan domain.AddItemResult, domain.AddItemsResponse, error) {
	ret := _m.Called(ctx, sourcePaths, targetPath, bucketName)

	var r0 <-chan domain.AddItemResult
	if rf, ok := ret.Get(0).(func(context.Context, []string, string, string) <-chan domain.AddItemResult); ok {
		r0 = rf(ctx, sourcePaths, targetPath, bucketName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan domain.AddItemResult)
		}
	}

	var r1 domain.AddItemsResponse
	if rf, ok := ret.Get(1).(func(context.Context, []string, string, string) domain.AddItemsResponse); ok {
		r1 = rf(ctx, sourcePaths, targetPath, bucketName)
	} else {
		r1 = ret.Get(1).(domain.AddItemsResponse)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, []string, string, string) error); ok {
		r2 = rf(ctx, sourcePaths, targetPath, bucketName)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// AddRecentlySharedPublicKeys provides a mock function with given fields: ctx, pubkeys
func (_m *Service) AddRecentlySharedPublicKeys(ctx context.Context, pubkeys []crypto.PubKey) error {
	ret := _m.Called(ctx, pubkeys)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []crypto.PubKey) error); ok {
		r0 = rf(ctx, pubkeys)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BackupKeysByPassphrase provides a mock function with given fields: ctx, uuid, pass
func (_m *Service) BackupKeysByPassphrase(ctx context.Context, uuid string, pass string) error {
	ret := _m.Called(ctx, uuid, pass)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, uuid, pass)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateBucket provides a mock function with given fields: ctx, slug
func (_m *Service) CreateBucket(ctx context.Context, slug string) (textile.Bucket, error) {
	ret := _m.Called(ctx, slug)

	var r0 textile.Bucket
	if rf, ok := ret.Get(0).(func(context.Context, string) textile.Bucket); ok {
		r0 = rf(ctx, slug)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(textile.Bucket)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, slug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateFolder provides a mock function with given fields: ctx, path, bucketName
func (_m *Service) CreateFolder(ctx context.Context, path string, bucketName string) error {
	ret := _m.Called(ctx, path, bucketName)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, path, bucketName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateIdentity provides a mock function with given fields: ctx, username
func (_m *Service) CreateIdentity(ctx context.Context, username string) (*domain.Identity, error) {
	ret := _m.Called(ctx, username)

	var r0 *domain.Identity
	if rf, ok := ret.Get(0).(func(context.Context, string) *domain.Identity); ok {
		r0 = rf(ctx, username)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Identity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, username)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateLocalKeysBackup provides a mock function with given fields: ctx, pathToKeyBackup
func (_m *Service) CreateLocalKeysBackup(ctx context.Context, pathToKeyBackup string) error {
	ret := _m.Called(ctx, pathToKeyBackup)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, pathToKeyBackup)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteKeypair provides a mock function with given fields: ctx
func (_m *Service) DeleteKeypair(ctx context.Context) error {
	ret := _m.Called(ctx)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GenerateFileSharingLink provides a mock function with given fields: ctx, encryptionPassword, path, bucketName, dbID
func (_m *Service) GenerateFileSharingLink(ctx context.Context, encryptionPassword string, path string, bucketName string, dbID string) (domain.FileSharingInfo, error) {
	ret := _m.Called(ctx, encryptionPassword, path, bucketName, dbID)

	var r0 domain.FileSharingInfo
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, string) domain.FileSharingInfo); ok {
		r0 = rf(ctx, encryptionPassword, path, bucketName, dbID)
	} else {
		r0 = ret.Get(0).(domain.FileSharingInfo)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string, string) error); ok {
		r1 = rf(ctx, encryptionPassword, path, bucketName, dbID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateFilesSharingLink provides a mock function with given fields: ctx, encryptionPassword, paths, bucketName, dbID
func (_m *Service) GenerateFilesSharingLink(ctx context.Context, encryptionPassword string, paths []string, bucketName string, dbID string) (domain.FileSharingInfo, error) {
	ret := _m.Called(ctx, encryptionPassword, paths, bucketName, dbID)

	var r0 domain.FileSharingInfo
	if rf, ok := ret.Get(0).(func(context.Context, string, []string, string, string) domain.FileSharingInfo); ok {
		r0 = rf(ctx, encryptionPassword, paths, bucketName, dbID)
	} else {
		r0 = ret.Get(0).(domain.FileSharingInfo)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, []string, string, string) error); ok {
		r1 = rf(ctx, encryptionPassword, paths, bucketName, dbID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenerateKeyPair provides a mock function with given fields: ctx, useForce
func (_m *Service) GenerateKeyPair(ctx context.Context, useForce bool) (string, error) {
	ret := _m.Called(ctx, useForce)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context, bool) string); ok {
		r0 = rf(ctx, useForce)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, bool) error); ok {
		r1 = rf(ctx, useForce)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAPISessionTokens provides a mock function with given fields: ctx
func (_m *Service) GetAPISessionTokens(ctx context.Context) (*domain.APISessionTokens, error) {
	ret := _m.Called(ctx)

	var r0 *domain.APISessionTokens
	if rf, ok := ret.Get(0).(func(context.Context) *domain.APISessionTokens); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.APISessionTokens)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConfig provides a mock function with given fields: ctx
func (_m *Service) GetConfig(ctx context.Context) domain.AppConfig {
	ret := _m.Called(ctx)

	var r0 domain.AppConfig
	if rf, ok := ret.Get(0).(func(context.Context) domain.AppConfig); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(domain.AppConfig)
	}

	return r0
}

// GetHubAuthToken provides a mock function with given fields: ctx
func (_m *Service) GetHubAuthToken(ctx context.Context) (string, error) {
	ret := _m.Called(ctx)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIdentityByUsername provides a mock function with given fields: ctx, username
func (_m *Service) GetIdentityByUsername(ctx context.Context, username string) (*domain.Identity, error) {
	ret := _m.Called(ctx, username)

	var r0 *domain.Identity
	if rf, ok := ret.Get(0).(func(context.Context, string) *domain.Identity); ok {
		r0 = rf(ctx, username)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.Identity)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, username)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMnemonic provides a mock function with given fields: ctx
func (_m *Service) GetMnemonic(ctx context.Context) (string, error) {
	ret := _m.Called(ctx)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNotifications provides a mock function with given fields: ctx, seek, limit
func (_m *Service) GetNotifications(ctx context.Context, seek string, limit int) ([]*domain.Notification, error) {
	ret := _m.Called(ctx, seek, limit)

	var r0 []*domain.Notification
	if rf, ok := ret.Get(0).(func(context.Context, string, int) []*domain.Notification); ok {
		r0 = rf(ctx, seek, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*domain.Notification)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, int) error); ok {
		r1 = rf(ctx, seek, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNotificationsLastSeenAt provides a mock function with given fields:
func (_m *Service) GetNotificationsLastSeenAt() (int64, error) {
	ret := _m.Called()

	var r0 int64
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPublicKey provides a mock function with given fields: ctx
func (_m *Service) GetPublicKey(ctx context.Context) (string, error) {
	ret := _m.Called(ctx)

	var r0 string
	if rf, ok := ret.Get(0).(func(context.Context) string); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSharedWithMeFiles provides a mock function with given fields: ctx, seek, limit
func (_m *Service) GetSharedWithMeFiles(ctx context.Context, seek string, limit int) ([]*domain.SharedDirEntry, string, error) {
	ret := _m.Called(ctx, seek, limit)

	var r0 []*domain.SharedDirEntry
	if rf, ok := ret.Get(0).(func(context.Context, string, int) []*domain.SharedDirEntry); ok {
		r0 = rf(ctx, seek, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*domain.SharedDirEntry)
		}
	}

	var r1 string
	if rf, ok := ret.Get(1).(func(context.Context, string, int) string); ok {
		r1 = rf(ctx, seek, limit)
	} else {
		r1 = ret.Get(1).(string)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, string, int) error); ok {
		r2 = rf(ctx, seek, limit)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// HandleSharedFilesInvitation provides a mock function with given fields: ctx, invitationId, accept
func (_m *Service) HandleSharedFilesInvitation(ctx context.Context, invitationId string, accept bool) error {
	ret := _m.Called(ctx, invitationId, accept)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) error); ok {
		r0 = rf(ctx, invitationId, accept)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// JoinBucket provides a mock function with given fields: ctx, slug, threadinfo
func (_m *Service) JoinBucket(ctx context.Context, slug string, threadinfo *domain.ThreadInfo) (bool, error) {
	ret := _m.Called(ctx, slug, threadinfo)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, string, *domain.ThreadInfo) bool); ok {
		r0 = rf(ctx, slug, threadinfo)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, *domain.ThreadInfo) error); ok {
		r1 = rf(ctx, slug, threadinfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListBuckets provides a mock function with given fields: ctx
func (_m *Service) ListBuckets(ctx context.Context) ([]textile.Bucket, error) {
	ret := _m.Called(ctx)

	var r0 []textile.Bucket
	if rf, ok := ret.Get(0).(func(context.Context) []textile.Bucket); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]textile.Bucket)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDir provides a mock function with given fields: ctx, path, bucketName, listSubfolderContent, listMembers
func (_m *Service) ListDir(ctx context.Context, path string, bucketName string, listSubfolderContent bool, listMembers bool) ([]domain.FileInfo, error) {
	ret := _m.Called(ctx, path, bucketName, listSubfolderContent, listMembers)

	var r0 []domain.FileInfo
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, bool) []domain.FileInfo); ok {
		r0 = rf(ctx, path, bucketName, listSubfolderContent, listMembers)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.FileInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool, bool) error); ok {
		r1 = rf(ctx, path, bucketName, listSubfolderContent, listMembers)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDirs provides a mock function with given fields: ctx, path, bucketName, listSubfolderContent, listMembers
func (_m *Service) ListDirs(ctx context.Context, path string, bucketName string, listSubfolderContent bool, listMembers bool) ([]domain.FileInfo, error) {
	ret := _m.Called(ctx, path, bucketName, listSubfolderContent, listMembers)

	var r0 []domain.FileInfo
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool, bool) []domain.FileInfo); ok {
		r0 = rf(ctx, path, bucketName, listSubfolderContent, listMembers)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.FileInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, bool, bool) error); ok {
		r1 = rf(ctx, path, bucketName, listSubfolderContent, listMembers)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenFile provides a mock function with given fields: ctx, path, bucketName, dbID
func (_m *Service) OpenFile(ctx context.Context, path string, bucketName string, dbID string) (domain.OpenFileInfo, error) {
	ret := _m.Called(ctx, path, bucketName, dbID)

	var r0 domain.OpenFileInfo
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) domain.OpenFileInfo); ok {
		r0 = rf(ctx, path, bucketName, dbID)
	} else {
		r0 = ret.Get(0).(domain.OpenFileInfo)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, path, bucketName, dbID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenSharedFile provides a mock function with given fields: ctx, cid, password, filename
func (_m *Service) OpenSharedFile(ctx context.Context, cid string, password string, filename string) (domain.OpenFileInfo, error) {
	ret := _m.Called(ctx, cid, password, filename)

	var r0 domain.OpenFileInfo
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) domain.OpenFileInfo); ok {
		r0 = rf(ctx, cid, password, filename)
	} else {
		r0 = ret.Get(0).(domain.OpenFileInfo)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, cid, password, filename)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RecentlySharedPublicKeys provides a mock function with given fields: ctx
func (_m *Service) RecentlySharedPublicKeys(ctx context.Context) ([]crypto.PubKey, error) {
	ret := _m.Called(ctx)

	var r0 []crypto.PubKey
	if rf, ok := ret.Get(0).(func(context.Context) []crypto.PubKey); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]crypto.PubKey)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RecoverKeysByLocalBackup provides a mock function with given fields: ctx, pathToKeyBackup
func (_m *Service) RecoverKeysByLocalBackup(ctx context.Context, pathToKeyBackup string) error {
	ret := _m.Called(ctx, pathToKeyBackup)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, pathToKeyBackup)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RecoverKeysByPassphrase provides a mock function with given fields: ctx, uuid, pass
func (_m *Service) RecoverKeysByPassphrase(ctx context.Context, uuid string, pass string) error {
	ret := _m.Called(ctx, uuid, pass)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, uuid, pass)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RegisterSyncer provides a mock function with given fields: sync
func (_m *Service) RegisterSyncer(sync services.Syncer) {
	_m.Called(sync)
}

// RestoreKeyPairFromMnemonic provides a mock function with given fields: ctx, mnemonic
func (_m *Service) RestoreKeyPairFromMnemonic(ctx context.Context, mnemonic string) error {
	ret := _m.Called(ctx, mnemonic)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, mnemonic)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetNotificationsLastSeenAt provides a mock function with given fields: timestamp
func (_m *Service) SetNotificationsLastSeenAt(timestamp int64) error {
	ret := _m.Called(timestamp)

	var r0 error
	if rf, ok := ret.Get(0).(func(int64) error); ok {
		r0 = rf(timestamp)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ShareBucket provides a mock function with given fields: ctx, slug
func (_m *Service) ShareBucket(ctx context.Context, slug string) (*domain.ThreadInfo, error) {
	ret := _m.Called(ctx, slug)

	var r0 *domain.ThreadInfo
	if rf, ok := ret.Get(0).(func(context.Context, string) *domain.ThreadInfo); ok {
		r0 = rf(ctx, slug)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.ThreadInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, slug)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ShareFilesViaPublicKey provides a mock function with given fields: ctx, paths, pubkeys
func (_m *Service) ShareFilesViaPublicKey(ctx context.Context, paths []domain.FullPath, pubkeys []crypto.PubKey) error {
	ret := _m.Called(ctx, paths, pubkeys)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []domain.FullPath, []crypto.PubKey) error); ok {
		r0 = rf(ctx, paths, pubkeys)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// TestPassphrase provides a mock function with given fields: ctx, uuid, pass
func (_m *Service) TestPassphrase(ctx context.Context, uuid string, pass string) error {
	ret := _m.Called(ctx, uuid, pass)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, uuid, pass)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ToggleBucketBackup provides a mock function with given fields: ctx, bucketName, bucketBackup
func (_m *Service) ToggleBucketBackup(ctx context.Context, bucketName string, bucketBackup bool) error {
	ret := _m.Called(ctx, bucketName, bucketBackup)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool) error); ok {
		r0 = rf(ctx, bucketName, bucketBackup)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
