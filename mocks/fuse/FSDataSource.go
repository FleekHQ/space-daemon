// Code generated by mockery v2.0.3. DO NOT EDIT.

package fuse

import (
	context "context"

	fsds "github.com/FleekHQ/space-daemon/core/fsds"
	mock "github.com/stretchr/testify/mock"

	os "os"
)

// FSDataSource is an autogenerated mock type for the FSDataSource type
type FSDataSource struct {
	mock.Mock
}

// CreateEntry provides a mock function with given fields: ctx, path, mode
func (_m *FSDataSource) CreateEntry(ctx context.Context, path string, mode os.FileMode) (*fsds.DirEntry, error) {
	ret := _m.Called(ctx, path, mode)

	var r0 *fsds.DirEntry
	if rf, ok := ret.Get(0).(func(context.Context, string, os.FileMode) *fsds.DirEntry); ok {
		r0 = rf(ctx, path, mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsds.DirEntry)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, os.FileMode) error); ok {
		r1 = rf(ctx, path, mode)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteEntry provides a mock function with given fields: ctx, path
func (_m *FSDataSource) DeleteEntry(ctx context.Context, path string) error {
	ret := _m.Called(ctx, path)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, path)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: ctx, path
func (_m *FSDataSource) Get(ctx context.Context, path string) (*fsds.DirEntry, error) {
	ret := _m.Called(ctx, path)

	var r0 *fsds.DirEntry
	if rf, ok := ret.Get(0).(func(context.Context, string) *fsds.DirEntry); ok {
		r0 = rf(ctx, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fsds.DirEntry)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetChildren provides a mock function with given fields: ctx, path
func (_m *FSDataSource) GetChildren(ctx context.Context, path string) ([]*fsds.DirEntry, error) {
	ret := _m.Called(ctx, path)

	var r0 []*fsds.DirEntry
	if rf, ok := ret.Get(0).(func(context.Context, string) []*fsds.DirEntry); ok {
		r0 = rf(ctx, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*fsds.DirEntry)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Open provides a mock function with given fields: ctx, path
func (_m *FSDataSource) Open(ctx context.Context, path string) (fsds.FileReadWriterCloser, error) {
	ret := _m.Called(ctx, path)

	var r0 fsds.FileReadWriterCloser
	if rf, ok := ret.Get(0).(func(context.Context, string) fsds.FileReadWriterCloser); ok {
		r0 = rf(ctx, path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(fsds.FileReadWriterCloser)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RenameEntry provides a mock function with given fields: ctx, oldPath, newPath
func (_m *FSDataSource) RenameEntry(ctx context.Context, oldPath string, newPath string) error {
	ret := _m.Called(ctx, oldPath, newPath)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, oldPath, newPath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
